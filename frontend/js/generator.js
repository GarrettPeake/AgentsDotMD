/**
 * Markdown assembly engine.
 * Generates the final output file from selected technologies, options, and fragments.
 */
import { store } from './store.js';

/**
 * Generates the main markdown file from current store state.
 * Assembles header, sorts and filters fragments, applies local edits.
 * @returns {string} The assembled markdown content.
 */
export function generate() {
  const selectedTechIds = store.get('selectedTechIds') || [];
  const options = store.get('options') || {};
  const fragments = store.get('fragments') || [];
  const localEdits = store.get('localEdits') || {};
  const filename = store.get('filename') || 'AGENTS.md';
  const technologies = store.get('technologies') || [];

  const header = buildHeader(selectedTechIds, options, technologies, filename);
  const filtered = filterFragments(fragments, options);
  const sorted = sortFragments(filtered);
  const grouped = groupByTechnology(sorted);
  const body = assembleBody(grouped, localEdits, technologies);
  const result = header + '\n\n' + body;

  store.set('generatedMarkdown', result);
  return result;
}

/**
 * Generates markdown with template file contents appended as fenced code blocks.
 * This is the "inline instructions" delivery mode (FR-403b).
 * @returns {string} The assembled markdown with inline template content.
 */
export function generateInlineMode() {
  const markdown = generate();
  const templateFiles = store.get('templateFiles') || [];
  const options = store.get('options') || {};

  if (templateFiles.length === 0) {
    return markdown;
  }

  const lines = [
    markdown,
    '',
    '---',
    '',
    '## Setup Files',
    '',
    'Create the following files in your project:',
    '',
  ];

  for (const template of templateFiles) {
    const interpolatedContent = interpolateSimple(template.content, options);
    lines.push(`### \`${template.outputPath}\``);
    lines.push('');
    lines.push('```' + getFileExtension(template.outputPath));
    lines.push(interpolatedContent);
    lines.push('```');
    lines.push('');
  }

  const result = lines.join('\n');
  store.set('generatedMarkdown', result);
  return result;
}

/**
 * Generates a meta-prompt that instructs an AI agent to create all files.
 * This is the "copy-paste prompt" delivery mode (FR-403c).
 * @returns {string} The meta-prompt string.
 */
export function generateCopyPasteMode() {
  const selectedTechIds = store.get('selectedTechIds') || [];
  const technologies = store.get('technologies') || [];
  const templateFiles = store.get('templateFiles') || [];
  const options = store.get('options') || {};
  const filename = store.get('filename') || 'AGENTS.md';

  const selectedTechs = technologies.filter(t => selectedTechIds.includes(t.id));
  const techNames = selectedTechs.map(t => t.name).join(', ');

  const markdown = generate();

  const lines = [
    'I need you to set up the following files in my project.',
    '',
    `Technologies: ${techNames}`,
    '',
    `## File 1: \`${filename}\``,
    '',
    'Create this file with the following content:',
    '',
    '````markdown',
    markdown,
    '````',
    '',
  ];

  if (templateFiles.length > 0) {
    let fileIndex = 2;
    for (const template of templateFiles) {
      const interpolatedContent = interpolateSimple(template.content, options);
      lines.push(`## File ${fileIndex}: \`${template.outputPath}\``);
      lines.push('');
      lines.push('Create this file with the following content:');
      lines.push('');
      lines.push('```' + getFileExtension(template.outputPath));
      lines.push(interpolatedContent);
      lines.push('```');
      lines.push('');
      fileIndex++;
    }
  }

  lines.push('Please create all of the above files in the project root directory.');

  const result = lines.join('\n');
  store.set('generatedMarkdown', result);
  return result;
}

/**
 * Builds the header section of the generated markdown.
 * @param {string[]} selectedTechIds
 * @param {Object} options
 * @param {Array} technologies
 * @param {string} filename
 * @returns {string}
 */
function buildHeader(selectedTechIds, options, technologies, filename) {
  const selectedTechs = technologies.filter(t => selectedTechIds.includes(t.id));
  const techNames = selectedTechs.map(t => t.name);
  const timestamp = new Date().toISOString().split('T')[0];

  const lines = [
    `# ${filename.replace(/\.md$/, '')}`,
    '',
    `> Generated by [AgentsDotMD](https://agentsdotmd.com) on ${timestamp}`,
    '',
    '## Technologies',
    '',
  ];

  for (const name of techNames) {
    lines.push(`- ${name}`);
  }

  const optionEntries = buildOptionsSummary(selectedTechIds, options, technologies);
  if (optionEntries.length > 0) {
    lines.push('');
    lines.push('## Configuration');
    lines.push('');
    for (const entry of optionEntries) {
      lines.push(`- **${entry.label}**: ${entry.value}`);
    }
  }

  return lines.join('\n');
}

/**
 * Builds a summary of selected options for the header.
 * @param {string[]} selectedTechIds
 * @param {Object} options
 * @param {Array} technologies
 * @returns {Array<{ label: string, value: string }>}
 */
function buildOptionsSummary(selectedTechIds, options, technologies) {
  const entries = [];

  for (const techId of selectedTechIds) {
    const tech = technologies.find(t => t.id === techId);
    if (!tech || !tech.options) {
      continue;
    }

    const techOptions = options[techId] || {};
    for (const opt of tech.options) {
      const value = techOptions[opt.id];
      if (value !== undefined && value !== null && value !== '') {
        entries.push({
          label: `${tech.name} â€” ${opt.label}`,
          value: String(value),
        });
      }
    }
  }

  return entries;
}

/**
 * Filters fragments based on option dependencies.
 * A fragment is included if it has no optionDependencies, or if all
 * its dependencies are satisfied by the current options.
 * @param {Array} fragments
 * @param {Object} options
 * @returns {Array}
 */
function filterFragments(fragments, options) {
  return fragments.filter(fragment => {
    const deps = fragment.metadata && fragment.metadata.optionDependencies;
    if (!deps || typeof deps !== 'object') {
      return true;
    }

    for (const [optionId, requiredValue] of Object.entries(deps)) {
      const techId = fragment.metadata.technology;
      const techOptions = options[techId] || {};
      const currentValue = techOptions[optionId];

      if (Array.isArray(requiredValue)) {
        if (!requiredValue.includes(currentValue)) {
          return false;
        }
      } else if (currentValue !== requiredValue) {
        return false;
      }
    }

    return true;
  });
}

/**
 * Sorts fragments by sortOrder (ascending).
 * General fragments (100) first, tech-specific (200+), combinations (500+).
 * @param {Array} fragments
 * @returns {Array}
 */
function sortFragments(fragments) {
  return [...fragments].sort((a, b) => {
    const orderA = (a.metadata && a.metadata.sortOrder) || 999;
    const orderB = (b.metadata && b.metadata.sortOrder) || 999;
    return orderA - orderB;
  });
}

/**
 * Groups fragments by their technology ID.
 * @param {Array} fragments
 * @returns {Map<string, Array>} Map of technologyId -> fragments.
 */
function groupByTechnology(fragments) {
  const groups = new Map();

  for (const fragment of fragments) {
    const techId = (fragment.metadata && fragment.metadata.technology) || '_general';
    if (!groups.has(techId)) {
      groups.set(techId, []);
    }
    groups.get(techId).push(fragment);
  }

  return groups;
}

/**
 * Assembles the markdown body from grouped fragments, applying local edits.
 * @param {Map<string, Array>} grouped - Grouped fragments.
 * @param {Object} localEdits - Map of fragmentId -> edited content.
 * @param {Array} technologies - All technologies from the manifest.
 * @returns {string}
 */
function assembleBody(grouped, localEdits, technologies) {
  const sections = [];

  for (const [techId, fragments] of grouped) {
    if (techId !== '_general') {
      const tech = technologies.find(t => t.id === techId);
      const heading = tech ? tech.name : techId;
      sections.push(`## ${heading}`);
      sections.push('');
    }

    for (const fragment of fragments) {
      const fragmentId = fragment.id;
      const content = localEdits[fragmentId] !== undefined
        ? localEdits[fragmentId]
        : fragment.content;
      sections.push(content);
      sections.push('');
    }
  }

  return sections.join('\n').trim();
}

/**
 * Simple variable interpolation for template content.
 * Replaces {{variableName}} with values from the options object.
 * Flattens nested options (techId.optionId) for lookup.
 * @param {string} content
 * @param {Object} options
 * @returns {string}
 */
function interpolateSimple(content, options) {
  const flatOptions = {};
  for (const [techId, techOpts] of Object.entries(options)) {
    if (typeof techOpts === 'object' && techOpts !== null) {
      for (const [key, value] of Object.entries(techOpts)) {
        flatOptions[key] = value;
        flatOptions[`${techId}.${key}`] = value;
      }
    }
  }

  return content.replace(/\{\{([^}]+)\}\}/g, (match, varName) => {
    const trimmed = varName.trim();
    return flatOptions[trimmed] !== undefined ? String(flatOptions[trimmed]) : match;
  });
}

/**
 * Extracts a file extension hint for fenced code blocks.
 * @param {string} filePath
 * @returns {string}
 */
function getFileExtension(filePath) {
  const ext = filePath.split('.').pop();
  const extensionMap = {
    toml: 'toml',
    json: 'json',
    yaml: 'yaml',
    yml: 'yaml',
    js: 'javascript',
    ts: 'typescript',
    py: 'python',
    rb: 'ruby',
    sh: 'bash',
    bash: 'bash',
    md: 'markdown',
    html: 'html',
    css: 'css',
    xml: 'xml',
  };
  return extensionMap[ext] || ext || '';
}
